# Database Systems Project

## Table of Contents

- [Info](#info)
- [System Design](#system-design)
  - [Database Design](#database-design)
  - [Software Design](#software-design)
  - [Technical Dependencies](#technical-dependencies)
  - [Handling the Migration Data](#handling-the-migration-data)
  - [Error Handling, Validation and Execution](#error-handling-validation-and-execution)
- [Quick Start](#quick-start)
  - [The Home Page](#the-home-page)
  - [Search Books](#search-books)
  - [Search Borrowers](#search-borrowers)
  - [Create Borrowers](#create-borrowers)
  - [Settings](#settings)
  - [Time Travel](#time-travel)
  - [Quit](#quit)
- [Setup](#setup)
  - [Python Version](#python-version)
  - [Dependencies](#dependencies)
- [Running the Project](#running-the-project)
  - [First Run](#first-run)
  - [Normal Operation](#normal-operation)
  - [Resetting Progress](#resetting-progress)

## Info

This following project represents a Library Management System operated by a librarian to handle checking in and out books, and managing borrowers and their associated fines.

## System Design

For simplicity of setup/build, we are using SQLite, since it works nicely ootb with no setup outside of Python script.

The project uses a layered architecture pattern which separates the presentation, data model and persistence layers.

### Database Design

1. Books (BOOK)
- Isbn: Serves as the Primary Key. Stored as a TEXT string to preserve leading zeros or dashes.
- Title: The title of the book as a string.

2. Authors (AUTHORS)
- Author_id: A unique identifier for the author.
- Name: The full name of the author.

3. Book Authors (BOOK_AUTHORS)
- Author_id: Links to the AUTHORS table for a particular author.
- Isbn: Links to the BOOK table for a particular book.
- The primary key is a composite of Author_id and Isbn ensuring that a specific author cannot be assigned multiple of the exact same book.

4. Borrowers (BORROWER)
- Card_id: A unique ID automatically generated by the database, since the migration data is ordered before insertion and is guaranteed to be contiguous.
Ssn: Social Security Number. Stored as TEXT to handle non-numeric values in the data (dashes).
Bname: Borrower's full name.
Address: Borrower's physical address as a string.
Phone: Phone number as string to preserve leading zeros, parens and dashes.

5. Book Loans (BOOK_LOANS)
- Loan_id: Unique ID for every specific checkout event.
- Isbn: The book being borrowed.
- Card_id: The id of the borrower responsible.
- Date_out: The date the book was checked out. Stored as a string in YYYY-MM-DD format.
- Due_date: The deadline for return (Date_out + 14 days).
- Date_in: The actual return date. If this is NULL, the book is currently checked out.

6. Fines (FINES)
- Loan_id: Links with a specific loan in the BOOK_LOANS table.
- Fine_amt: The total fine. Stored as Cents (Integer) rather than Dollars (Float) to avoid floating-point errors but are automatically converted by the program on print to dollars and cents.
- Paid: A boolean flag (0 or 1) indicating if the fine has been fully paid, since SQLite uses Integers for booleans.

7. Metadata (METADATA)
- key: The setting name (e.g., "current_date").
- value: The setting value.
- These are useful for a variety of database config information that is not relevant to the user. Such as current date (in time travel mode), and when fines were last updated (since fines update only when the application is running we need to know if a day has past since it was updated).

Much of the code that does the execution of these SQL queries is wrapped in a few helper functions that limit the way the database can be queried. For example, `get_one_or_none()` accepts a SQL query and parameters and attempts to return exactly one value as a result, otherwise None. While `get_many_or_none()` accepts a SQL query and a list of parameters where it is desirable to retreive a list of values. Additionally, all write operations use `try_execute_one()` or `try_execute_many()` which handle safely executing SQL write or updates.

### Software Design

We decided to use the popular Python library `Textual` to handle the graphical interface of the project. Textual is great because it simplified development nearly completely Python code and does not add any additional unecessary dependencies to the project. Because Textual is so versitile, we can run this application straight from the command line in TUI-mode or serve it up to be used across a network within the browser.

Again, to keep the dependencies small, we opted also to avoid the use of an ORM in favor of raw SQL queries. Since the application has such a simple set of operations and queries, this is feasible, however, upon scaling to more features and users we would likely consider using an ORM to better automate testing and handle fail states in code. Additionally, considering this project is largely focused on database fundamentals, raw queries seems to fit well.

Queries to the database tend to be returned as OperationResult objects where it is useful. This allows the ability to bundle executions state (failure or success) as well as a message that can be propogated to the user as to what went right (or wrong).

We also aimed to add a few additonal feautres to make testing the project go much more smoothly. A few of these features include: time-travel, where the librarian can peek at how data might look in the future; the ability to work with multiple databases with a convenient menu option to switch between them; and a mechanism to load in new randomized data to test against. Luckly, these tools also serve well as a sort of 'learning tool set' that operators of the application can use to aid their understanding of the application before working with real-world data.

We aimed to keep the architecture of this application as modular as possible by subclassing from built-in Textual classes to configure them directly to our needs. An example of this is the BaseModal class, which adds default styles to a modal class that all modals can inherit from.

Many of the components of the application also leverage the usefulness of Pydantic objects (the second and only other dependency of the project outside Python). This allows us to create models of our data objects and then perform so automatic validation or to run certain code when an object is used in a certain way. This is evident in how the authors list is returned from the SQL query in string format separated by commas but are automatically converted into python lists after added to the object, or how fines are automatically converted to dollars format when printed (since they are stored as cents).

### Technical Dependencies

- Language: Python (Minimum version 3.12)
- OS: Cross-platform (Windows, MacOS, Linux) due to Python/Textual.
- UI Framework: Textual
- Database: SQLite3
- Validation and In-Memory Data: Pydantic
- Package Manager: uv
- Virtual Environment: uv

### Handling the Migration Data

As far as parsing the migrated data, the system assumes it is in csv format and makes opinionated decisions based on what the previous file looks like (either tab-delimited or comma-delimited).

Most notably, the system strips out any HTML encoding and converts it to the proper ascii character (eg &amp; -> &).

Borrower IDs are converted from string IDXXXXXXX representation to pure integers. There is no worry about leading zeros as the data is validated to not have lost any data in this process.

### Error Handling, Validation and Execution

The application relies heavily on the OperationResult object to pass error states to the UI, which then displays them using `self.notify()`.

A brief breakdown of the error handling and data validation per major operation is follows. In each case, a message is attached with the appropriate reason:

Creating a Borrower
- Empty Fields: Checks if Name, SSN, Address, or Phone are empty.
- SSN Format: Must be numeric and exactly 9 digits (stripping dashes).
- Phone Format: Must be numeric and exactly 10 digits (stripping formatting characters).
- Duplicate SSN: Enforced by Database Unique Constraint (handled by generic SQL error catch).

Checking Out a Book
- Borrower Exists: Checks if ID exists.
- Max Checkouts: Checks if the borrower already has 3 or more active loans.
- Book Exists: Checks if ISBN is an entry in the database.
- Availability: Checks if the book is currently checked out.
- Unpaid Fines: Checks if the borrower has any existing fine records.

Checking In a Book
- Updates the Date_in field of the loan record to the current simulated date.

Paying Fines
- Borrower Exists: Validates ID.
- Insufficient Payment: Checks if amount provided is less than total fines owed.
- No Fines: Checks if the borrower actually has fines.
- Active Loans on Fines: Critical Rule: You cannot pay a fine for a book that hasn't been returned yet.

In general, a transaction is rolled back and the error is logged to the console for any errors that are not anticipated by the programmers.

## Quick Start

This section explains how to operate the project. See [Setup](#Setup) and [Running the Project](#Running-the-Project) for how to build and run the application for the first time.

### The Home Page

The home page is where all of the action begins. From you you can navigate to any of the submenus and modals detailed below.

### Search Books

One of the key features of the application is to all librarians to find and locate books to be checked in/out and managed. 

Search provides a text input and a data table to list books based on your queries.

Through the Search Books page you can:
- search for any book by isbn, book title or author name,
- filter your searches to a subset of the above fields, or by selecting whether you would like to see all books, or just those that are either available or unavailable (checked out). This can be accessed by pressing the Filter button in the top right corner and making the appropriate selections.

After searching for a desired book, the table should populate with a list of suggested titles based on your query. From left to right it shows the books ISBN, title, a list of authors, and its current status (available or unavailable). If it is unavailable, it will also show the corresponding borrower's id next to the status.

When you find a book you are interested in, click on it and you will be greeted by the book detail modal. This view allows you to view some basic information about the text as well as perform some actions.

Try selecting one of the author tiles and you will see that it repopulates the search with a query for books matching this authors name. 

Navigating to the Manage tab of the Book Details modal you can see an option to checkin or checkout the selected book. This view is dynamic depending on the status of the selected book. After a successful check-out, you can now navigate back to the book detail page and see that this book is now associate with a borrower.

To see a full history of the books checkins and checkouts, navigate to the Checkout History tab and browse the table.

Press Close to return to the search view.

When you are done with the Search Books page, press the back button in the top right corner to navigate backwards to the home page.

### Search Borrowers

Seaching of borrowers is very similar to the Search Books page.

Upon searching for a book you will see the table populate with the Borrower's Card ID, their name, followed by a number of checkouts and any built up fines. Keep in mind that these fines include the total fines across both existing and estimated fines for books that are overdue but still not checked in.

Click on the a borrower to view their details in full.

The info card is fairly standard, but navigating to the Manage tab we can see some useful information. If the borrower has no books actively checked out and no pending fines, we see a simple text label with the appropriate description. Otherwise, if a borrower has books actively checked out we see a selection list with the ISBNs and titles of the books they have checked out. From here you can make a selection or more, press Check-in and the books will be returned to the library.

Below this Active Checkouts section we can see some information on the users fines. We see the amount incurred per book as well as a total below of what needs to be paid. When a borrower has returned all of their overdue books, and they make a payment, press the Pay button to resolve these fines.

For a detailed breakdown of the rules for books and fines, see the system design section of this readme.

Lastly, the Checkout History has the same layout of that in the Search Books detail modal, except it filters checkout history by borrower ID, not book.

Again, press Close and then Back to return to the home page.

### Create Borrowers

Create Borrower allows you to enter in a borrower's information and register them with the library. It's functionality is very straight-forward, so we won't dive any deeper.

See the system design section of this readme for a breakdown of the rules in creating a new borrower.

### Settings

Within this settings modal there are a few advanced options that administrators can take advantage of such as: 
- Change the active database by typing in a new filename in the prompt and pressing "change".
- Initialize an existing but un-initialized database. This is relevant mainly only after you have changed the database name from the option listed above.
- Re-Initialize the current database. This will delete any created data and start fresh (after re-loading the initial migration data first).
- Reset the time feature. This is important when testing data with the "time-travel" menu testing item. It allows you to undo the 'go forward in time and set the simulated date to today'.
- And lastly, "Load Extra Data" which is helpful for testing/learning purposes to load in a selection of random example loan data into the application.

### Time Travel

Time Travel is a neat little feature that is handy in testing and learning about this tool before working with real-world data. It allows you to have the functionality to create loans between borrowers and then simulate the passage of time so that you can see the result of fines (for example). Click on the button and navigate forward in time. Once you pick a date you like, select it by pressing Confirm or cancel with Cancel. 

Note: you cannot move backwards in time after you have set a new date for 'today', although you can navigate forwards and backwards when selecting in the menu so long as you do not try and move back before 'todays' date. This sounds like a complex operation, but after playing around with it for a moment it should make sense. 

To reset the date to the real date, see the setting modal. Keep in mind again, this tool is only for demo and testing/learning purposes and would be removed in a production-ready system.

### Quit

Quit, as you might expect, shows a pop-up modal to close the application and leave. After pressing this, all data is saved from your current session.

## Setup

### Python Version

Ensure you are using at minimum python version 3.12.

This is the most widely-adopted of the recent python version. It has some nice features that make writing this code much better.

``` bash
python3 --version
```

### Dependencies

It is recommended that you use a virtual environment before continuing. This project was built using `uv` as it handles most of the annoying project config, but any venv will work.

You can [install uv here](https://docs.astral.sh/uv/getting-started/installation/).

To setup a venv with `uv`:

``` bash
uv venv
```

Remember to activate the venv afterwards using the command it spits back at you. On Linux this is simply:

``` bash
source .venv/bin/active
```

Install the project requirements:

``` bash
uv pip install -r requirements.txt
```

And you are ready to go.

## Running the Project

### First Run

Upon the first run of the project, a database must be created and initialized. When you first launch you will see a dialog prompting you to create a new database or quit the app. Pressing initialize will initialize the database and insert the migrated data into the system automatically.

### Normal Operation

Start the app with:

``` bash
uv run textual run src/app.py
```

If the textual command isn't found, just run it as a normal python file (not recommended).

``` bash
python3 src/app.py
```

It should open up a GUI/TUI in your terminal. To run it in the brower:

``` bash
uv run textual serve src/app.py
```

and open the corresponding port in your browser.

### Resetting Progress

To start with a fresh database, run the app and find the settings menu.

From here you can re-init the database, or optionally pass a new filename and initialize it.

NOTE: initializing the database loads in all of the given test data that is extracted from the csv files in `/data`.

WARNING: re-init removes all progress from created borrowers, checkouts, fines, etc. and just starts fresh with the given data.
